ython
with statement in Python
Generators in Python
When to use yield instead of return in Python?
Returning Multiple Values in Python
Python return statement
Important differences between Python 2.x and Python 3.x with examples
Keywords in Python – Set 1
Keywords in Python | Set 2
Namespaces and Scope in Python
Statement, Indentation and Comment in Python
How to assign values to variables in Python and other languages
How to print without newline in Python?
Python end parameter in print()
Python | sep parameter in print()
Python | Output Formatting
format() function in Python
f-strings in Python
Enumerate() in Python
Iterate over a list in Python
Print lists in Python (4 Different Ways)
Adding new column to existing DataFrame in Pandas
Python map() function
Taking input in Python
Python program to convert a list to string
How to get column names in Pandas dataframe
Reading and Writing to text files in Python
with statement in Python
Difficulty Level : Hard
 Last Updated : 15 Feb, 2019
with statement in Python is used in exception handling to make the code cleaner and much more readable. It simplifies the management of common resources like file streams. Observe the following code example on how the use of with statement makes code cleaner.

filter_none
brightness_4
# file handling 
  
# 1) without using with statement 
file = open('file_path', 'w') 
file.write('hello world !') 
file.close() 
  
# 2) without using with statement 
file = open('file_path', 'w') 
try: 
    file.write('hello world') 
finally: 
    file.close() 
 

filter_none
brightness_4
# using with statement 
with open('file_path', 'w') as file: 
    file.write('hello world !') 
Notice that unlike the first two implementations, there is no need to call file.close() when using with statement. The with statement itself ensures proper acquisition and release of resources. An exception during the file.write() call in the first implementation can prevent the file from closing properly which may introduce several bugs in the code, i.e. many changes in files do not go into effect until the file is properly closed.

The second approach in the above example takes care of all the exceptions but using the with statement makes the code compact and much more readable. Thus, with statement helps avoiding bugs and leaks by ensuring that a resource is properly released when the code using the resource is completely executed. The with statement is popularly used with file streams, as shown above and with Locks, sockets, subprocesses and telnets etc.

Supporting the “with” statement in user defined objects
There is nothing special in open() which makes it usable with the with statement and the same functionality can be provided in user defined objects. Supporting with statement in your objects will ensure that you never leave any resource open.
To use with statement in user defined objects you only need to add the methods __enter__() and __exit__() in the object methods. Consider the following example for further clarification.




filter_none
brightness_4
# a simple file writer object 
  
class MessageWriter(object): 
    def __init__(self, file_name): 
        self.file_name = file_name 
      
    def __enter__(self): 
        self.file = open(self.file_name, 'w') 
        return self.file
  
    def __exit__(self): 
        self.file.close() 
  
# using with statement with MessageWriter 
  
with MessageWriter('my_file.txt') as xfile: 
    xfile.write('hello world') 
Let’s examine the above code. If you notice, what follows the with keyword is the constructor of MessageWriter. As soon as the execution enters the context of the with statement a MessageWriter object is created and python then calls the __enter__() method. In this __enter__() method, initialize the resource you wish to use in the object. This __enter__() method should always return a descriptor of the acquired resource.

What are resource descriptors?
These are the handles provided by the operating system to access the requested resources. In the following code block, file is a descriptor of the file stream resource.

filter_none
brightness_4
file = open('hello.txt') 
In the MessageWriter example provided above, the __enter__() method creates a file descriptor and returns it. The name xfile here is used to refer to the file descriptor returned by the __enter__() method. The block of code which uses the acquired resource is placed inside the block of the with statement. As soon as the code inside the with block is executed, the __exit__() method is called. All the acquired resources are released in the __exit__() method. This is how we use the with statement with user defined objects.

This interface of __enter__() and __exit__() methods which provides the support of with statement in user defined objects is called Context Manager.

The contextlib module
A class based context manager as shown above is not the only way to support the with statement in user defined objects. The contextlib module provides a few more abstractions built upon the basic context manager interface. Here is how we can rewrite the context manager for the MessageWriter object using the contextlib module.

filter_none
brightness_4
from contextlib import contextmanager 
  
class MessageWriter(object): 
    def __init__(self, filename): 
        self.file_name = filename 
  
    @contextmanager
    def open_file(self): 
        try: 
            file = open(self.file_name, 'w') 
            yield file
        finally: 
            file.close() 
  
# usage 
message_writer = MessageWriter('hello.txt') 
with message_writer.open_file() as my_file: 
    my_file.write('hello world') 
In this code example, because of the yield statement in its definition, the function open_file() is a generator function.
When this open_file() function is called, it creates a resource descriptor named file. This resource descriptor is then passed to the caller and is represented here by the variable my_file. After the code inside the with block is executed the program control returns back to the open_file() function. The open_file() function resumes its execution and executes the code following the yield statement. This part of code which appears after the yield statement releases the acquired resources. The @contextmanager here is a decorator.

The previous class-based implementation and this generator-based implementation of context managers is internally the same. While the later seems more readable, it requires the knowledge of generators, decorators and yield.

Attention geek! Strengthen your foundations with the Python Programming Foundation Course and learn the basics.

To begin with, your interview preparations Enhance your Data Structures concepts with the Python DS Course.





RECOMMENDED ARTICLES
Page :
1
2
3
How to write an empty function in Python - pass statement?
04, May 16
Using else conditional statement with for loop in python
12, Apr 17
Statement, Indentation and Comment in Python
10, Dec 18
Python return statement
15, Nov 19
Python Continue Statement
20, Nov 19
Python break statement
20, Nov 19
Check multiple conditions in if statement - Python
10, Mar 20
Nested-if statement in Python
20, Mar 20
Python pass Statement
14, Jun 20
How to Use IF Statement in MySQL Using Python
03, Jan 21
Important differences between Python 2.x and Python 3.x with examples
25, Feb 16
Python | Set 4 (Dictionary, Keywords in Python)
09, Feb 16
Python | Sort Python Dictionaries by Key or Value
24, Jul 18
Python | Merge Python key values to list
31, Jul 19
Reading Python File-Like Objects from C | Python
06, Jun 19
Python | Add Logging to a Python Script
11, Jun 19
Python | Add Logging to Python Libraries
11, Jun 19
JavaScript vs Python : Can Python Overtop JavaScript by 2020?
12, Jun 19
Python | Visualizing O(n) using Python
17, Aug 19
Python | Index of Non-Zero elements in Python list
02, Sep 19
Python | Convert list to Python array
26, Sep 19
MySQL-Connector-Python module in Python
04, Mar 20
Python - Read blob object in python using wand library
21, Apr 20
Python | PRAW - Python Reddit API Wrapper
26, Apr 20

favorite_border
Like
0
first_page
Previous
Print All Leaf Nodes of a Binary Tree from left to right | Set-2 ( Iterative Approach )
Next
last_page
ssh command in Linux with Examples
Article Contributed By :
https://media.geeksforgeeks.org/auth/avatar.png
Manthanchauhan
@Manthanchauhan
Vote for difficulty
Current difficulty : Hard
Easy
Normal
Medium
Hard
Expert
Article Tags :
Python-exceptions 
python-object 
Python
Improve Article
Report Issue

COURSES
Data structures and algorithms - self placed
Data Structures and Algorithms – Self Paced Course
View Details


Coding Round Contests - Test Series
Free Coding Round Contests – Test Series
View Details


MOST POPULAR IN PYTHON
Read a file line by line in Python
Python String | replace()
sum() function in Python
append() and extend() in Python
Different ways to create Pandas Dataframe

MORE RELATED ARTICLES IN PYTHON
Python Dictionary
isupper(), islower(), lower(), upper() in Python and their applications
Python | Program to convert String to a List
Python String | split()
Python | Get a list as input from user

Writing code in comment? Please use ide.geeksforgeeks.org, generate link and share the link here.


Load Comments
GeeksforGeeks
5th Floor, A-118,
Sector-136, Noida, Uttar Pradesh - 201305
feedback@geeksforgeeks.org
Company
About Us
Careers
Privacy Policy
Contact Us
Learn
Algorithms
Data Structures
Languages
CS Subjects
Video Tutorials
Practice
Courses
Company-wise
Topic-wise
How to begin?
Contribute
Write an Article
Write Interview Experience
Internships
Videos
@geeksforgeeks , Some rights reserved
We use cookies to ensure you have the best browsing experience on our website. By using our site, you acknowledge that you have read and understood our Cookie Policy & Privacy Policy
Got It !
Lightbox